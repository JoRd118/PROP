import java.util.*;

public abstract class BranchBound {
  
  // Comptador per mantenir l'id de cada node nou
  private int comptadoridnode = 0;
  // Nom de l'algotirme
  private String nomalgoritme = "Branch and bound";

  public BranchBound() {}
  
  public SolucioQAP Calcular(int indexPlanetaCalcul, String[] mPlanetes, String[] mRecursos, 
                       double[][] mDistancies, int[][] mDisponibilitats, int[][] mNecessitats) {

    // Iniciem dades per fer el calcul.
    SolucioQAP sol = new SolucioQAP();
    sol.modificarPlaneta(mPlanetes[indexPlanetaCalcul]);

    // Variables de calculs de solucio
    boolean hiHaSolucio = false;

    boolean solucioTrobada = false;
    double millorRecorregut = 0;

    // Creem la matriu de necessitats pendents del planeta de calcul
    // tenint en compte que si te la necessitat d'un recurs
    // que ell mateix te disponible NO l'afegim.
    ArrayList<Integer> necessitatsPendents = new ArrayList<Integer>();
    
    for(int ir=0;ir<mRecursos.length;ir++) {
      if((mNecessitats[indexPlanetaCalcul][ir] == 1) && (mDisponibilitats[indexPlanetaCalcul][ir] != 1)) necessitatsPendents.add(ir);
    }

//*-----------------------------------------------------------------------------------
    System.out.print("  Nece Pend "+necessitatsPendents.size()+":");
    for(Integer ir: necessitatsPendents) System.out.print(" ["+ir+"-"+mRecursos[ir]+"]");
    System.out.println();
//-----------------------------------------------------------------------------------*/

    // Si no hi ha necessitats pendents: SOLUCIO(No necessita res mes)
    if(necessitatsPendents.size() < 1) {
      // SOLUCIO: El planeta no necessita res
      sol.modificarTerraformat(true);
      sol.modificarMillorRecorregut(0);
      sol.modificarObservacions("El planeta s'ha terraformat tot sol.");

    } else {
      // Continuem buscant ...

      // Planetes Pendents amb algun recurs disponible necessari pel
      // planeta de calcul
      ArrayList<Integer> planetesPendents = new ArrayList<Integer>();
    
      for(int ip=0;ip<mPlanetes.length;ip++) {
        // Saltem Planeta Calcul
        if(ip != indexPlanetaCalcul) {
          int coincidents = 0;
          for(Integer ir: necessitatsPendents){
            if(mDisponibilitats[ip][ir] == 1) coincidents++;
          }
          // Si hi ha coincidencies passo a planeta pendent
          if(coincidents >= 1) planetesPendents.add(ip);
        }
      }

//*-----------------------------------------------------------------------------------
      System.out.print("  Plan Pend "+planetesPendents.size()+":");
      for(Integer ip: planetesPendents) System.out.print(" ["+ip+"-"+mPlanetes[ip]+"("+mDistancies[indexPlanetaCalcul][ip]+")]");
      System.out.println();
//-----------------------------------------------------------------------------------*/

      // Ara comprovem si hi podra haver solucio

      // Fem un arraylist amb les necessitats pendents
      ArrayList<Integer> necPen = new ArrayList<Integer>(necessitatsPendents);
      // Anem recorrent els planetes pendents fins que no quedi cap necessitat per satisfer
      for(Integer ip: planetesPendents){
        // Fem servir un ListIterator per poder fer remove si cal
        ListIterator<Integer> listIterator = necPen.listIterator();
        while(listIterator.hasNext()) {
          int ir = listIterator.next();
          if(mDisponibilitats[ip][ir] == 1) listIterator.remove();
        }
      }
      // Si hem satisfet totes les necessitats pendents, hi haura solucio.
      if(necPen.size() == 0) hiHaSolucio = true;

      // Si nomes hi ha un planeta pendent es l'unica solucio.
      if(hiHaSolucio && (planetesPendents.size() == 1)) {
        // SOLUCIO(Nomes hi ha un possible planeta)
        sol.modificarTerraformat(true);
        sol.modificarMillorRecorregut(mDistancies[indexPlanetaCalcul][planetesPendents.get(0)]);
        sol.modificarObservacions("Nomes hi ha un possible planeta.");


      } else if(hiHaSolucio && (planetesPendents.size() >= 2)) {
          
          // Preparem la cua amb prioritat: Primer ordena per OrdrePrimer Invers.
          // Si son iguals, llavors desempata per OrdreSegon.
          PriorityQueue<bbNode> pqNodes = new PriorityQueue<bbNode>(10,  new Comparator<bbNode>() {
            public int compare(bbNode n1, bbNode n2) {
              int r = n2.obtenirOrdrePrimer()-n1.obtenirOrdrePrimer();
              if(r == 0) {
                double c = n1.obtenirOrdreSegon()-n2.obtenirOrdreSegon();
                if(c > 0) r = 1;
                else if(c<0) r = -1;
              } 
              return (r);
            }
          });

          // Creem l'ArrayList de nodes
          ArrayList<bbNode> llistaNodes = new ArrayList<bbNode>();
          // Creem el primer node
          ArrayList<Integer> iniCami = new ArrayList<Integer>();
          iniCami.add(indexPlanetaCalcul);
          bbNode nodeSel = new bbNode(comptadoridnode++, -1, indexPlanetaCalcul, false, false, 0, 0, 0, 0, 0, 
                                      iniCami, necessitatsPendents, planetesPendents);
          llistaNodes.add(nodeSel);

         
          // Iniciem bucle fins que no quedi cap mes node
          boolean bContinuem = false;
          do {
            // Definim nivell per tots els seus fills
            int nivell = nodeSel.obtenirNivell()+1;
            // Agafem pare per tots els seus fills
            int idpare = nodeSel.obtenirIdNode();
            // Ramifico totes les possibilitats de nodeSel i els poso en cua o els podo
            for(Integer idPlanetaVisitat: nodeSel.obtenirPlanetesPendents()){
              // Actualitzo recorregut
              double recorregut = nodeSel.obtenirRecorregut() + mDistancies[indexPlanetaCalcul][idPlanetaVisitat];
              // Si no hi ha solucio trobada o n'hi ha pero el recorregut ja es
              // millor que l'actual el descarto (podo)
              if((!solucioTrobada) || ((solucioTrobada) && (recorregut <= millorRecorregut))) {
                // Actualitzo necessitats pendents despres de visitar idPlanetaVisitat
                ArrayList<Integer> novesNecessitatsPendents = new ArrayList<Integer>();
                for(Integer idNecessitatPendent: nodeSel.obtenirNecessitatsPendents()){
                  if(mDisponibilitats[idPlanetaVisitat][idNecessitatPendent] != 1) {
                    novesNecessitatsPendents.add(idNecessitatPendent);
                  }
                }

                // Si no hi ha mes necessitats, es una solucio
                if(novesNecessitatsPendents.size() == 0) {
                  // Millor solucio fins al moment (no podat)(no en cua)
                  solucioTrobada = true;
                  millorRecorregut = recorregut;

                  ArrayList<Integer> nouCami = new ArrayList<Integer>(nodeSel.obtenirCami());
                  nouCami.add(idPlanetaVisitat);

                  bbNode nodeNou = new bbNode(comptadoridnode++, idpare, idPlanetaVisitat, true, false, nivell, 
                                              recorregut, 0, 0, 0, nouCami, null, null);
                  llistaNodes.add(nodeNou);

//                  millorSolucio.clear();
//                  millorSolucio = new ArrayList<Integer>(nodeSel.obtenirCami());
//                  millorSolucio.add(idPlanetaVisitat);

                } else {
  
                  // Refem planetes pendents
                  ArrayList<Integer> nousPlanetesPendents = new ArrayList<Integer>();
                  for(Integer ip: nodeSel.obtenirPlanetesPendents()){
                    // Saltem planeta actual
                  	if(ip != idPlanetaVisitat) {
                      // Nomes ens quedem planetes amb disponibilitats necessaries
                		  for(Integer ir: novesNecessitatsPendents){
	  		                if(mDisponibilitats[ip][ir] == 1) {
                          nousPlanetesPendents.add(ip);
	  		                  break; 
	  		                }
		                  }
                    }
                  }
                
                  // Només continuem si hi ha planetes pendents amb alguna disponibilitat necessaria
                  if(nousPlanetesPendents.size() >= 1) {

                    // Afegim el planeta al cami seguit
                    ArrayList<Integer> nouCami = new ArrayList<Integer>(nodeSel.obtenirCami());
                    nouCami.add(idPlanetaVisitat);

                    // Afegim node a la cua de prioritat de nodes pendents
                    // Ordre Primer = nivell
                    // Ordre Segon = recorregut
                    bbNode nodeNou = new bbNode(comptadoridnode++, idpare, idPlanetaVisitat, false, false, nivell, 
                                recorregut, 0, nivell, recorregut, nouCami, novesNecessitatsPendents, nousPlanetesPendents);
                    llistaNodes.add(nodeNou);
                    pqNodes.add(nodeNou); // Posat en cua (no podat)
                  }
                }
              }
            }

            // Inicialment continuem
            bContinuem = true;

            // Si ja tinc una solucio valida vaig descartant fins que trobo un amb cota millor
            if(solucioTrobada) {

              boolean propernode = true;
              while(propernode) {
                propernode=false;
                // Agafo proper node segons la prioritat de la PriorityQueue
                nodeSel = pqNodes.poll();
                if(nodeSel != null) {
                  // Calculo la cota
                  double cotarestant = 0;
                  double total = nodeSel.obtenirRecorregut();
                  // Cal que hi hagi com a minim dos planetes pendents
                  if(nodeSel.obtenirPlanetesPendents().size()>=2){
                    // Calculem la cota dels que queden
                    cotarestant = clcGilmore(nodeSel.obtenirPlanetesPendents(), nodeSel.obtenirNecessitatsPendents(), 
                                  mDisponibilitats, mDistancies[indexPlanetaCalcul]);
                  } else if(nodeSel.obtenirPlanetesPendents().size()==1) {
                    // En aquest cas es la distancia
                    cotarestant = mDistancies[indexPlanetaCalcul][nodeSel.obtenirPlanetesPendents().get(0)];
                  }
                  nodeSel.modificarCotaRestant(cotarestant);
                  // Si la cota no es bona agafo el proper node
                  total = total + cotarestant;
                  nodeSel.modificarOrdreSegon(total);
                  propernode=false;
                  if(millorRecorregut>=total) propernode=true;
                  else nodeSel.modificarDescartat(true);
                } else {
                  // Si no hi ha més nodes acabo
                  propernode=false;
                }
              }              
            } else {
              // Agafo proper node segons la prioritat de la PriorityQueue
              nodeSel = pqNodes.poll();
            }

            if(nodeSel == null) bContinuem = false;
          } while (bContinuem);

          if(solucioTrobada) {
            sol.modificarTerraformat(true);
            sol.modificarMillorRecorregut(millorRecorregut);
            sol.modificarObservacions("");
            sol.modificarLlistaNodes(llistaNodes);
          } else {
            // Impossible !!!
          }
//-----------------------------------------------------------------------------------*/
      } else {
        // No hi ha solucio
        sol.modificarObservacions("No hi ha solucio possible !");
      }
    }
    
    return sol;
  }

  // Calcul de la cota Gilmore-Lawler
  private double clcGilmore(ArrayList<Integer> planetes, ArrayList<Integer> necessitats, int[][] disponibilitats, double[] distancies) {
    double solucio = -1;
    // Planetes i disponibilitats ([1]: Planeta [2]: Recurs)
    // Agafem el maxim que pot ser
    int n = (planetes.size()+1) * necessitats.size();
    int [][] planec = new int[n][2];
    int nRang = 0;
    for(int ip:planetes) {
      for(int ir:necessitats) {
        // Nomes ens quedem les disponibilitats
        if(disponibilitats[ip][ir] == 1) {
          planec[nRang][0]=ip;
          planec[nRang][1]=ir;
          nRang++;
        }
      }
    }
    // Planeta de calcul, te totes les necessitats.
    for(int ir:necessitats) {
      planec[nRang][0]=-1;
      planec[nRang][1]=ir;
      nRang++;
    }
    // Ara muntem les matrius
    if(nRang >= 2) {
      // [A] Matriu de fluxes i --> j
      double[][] A = new double[nRang][nRang];
      // [B] Matriu de distancies (distancia o infinit)
      double[][] B = new double[nRang][nRang];
      // [C] Matriu de cost fix = 0
      double[][] C = new double[nRang][nRang];
      for(int i=0;i<nRang;i++) {
        int ipo = planec[i][0];
        int iro = planec[i][1];
        for(int j=0;j<nRang;j++) {
          int ipd = planec[j][0];
          int ird = planec[j][1];
          if(ipo >= 0) {
            if(ipd >= 0) {
              A[i][j] = 0;
              if(i == j) B[i][j] = 0; else B[i][j] = Double.MAX_VALUE;
            } else {
              if(iro == ird) A[i][j] = 1; else A[i][j] = 0;
              B[i][j] = distancies[ipo];
            }
          } else {
            if(ipd >= 0) {
              A[i][j] = 0;
              B[i][j] = distancies[ipd];              
            } else {
              A[i][j] = 0;
              if(i == j) B[i][j] = 0; else B[i][j] = Double.MAX_VALUE;
            }
          }
          C[i][j] = 0;
        }
      }
      
/*-----------------------------------------------------------------------------------
      System.out.println("...................");
      System.out.println("Pla Nec");
      for(int i=0;i<nRang;i++) {
        System.out.print(planec[i][0]);
        System.out.println(" " + planec[i][1]);
      }
      System.out.println("[A]");
      for(int i=0;i<nRang;i++) {
        for(int j=0;j<nRang;j++) {
          System.out.print(" " + A[i][j]);
        }
        System.out.println();
      }
      System.out.println("[B]");
      for(int i=0;i<nRang;i++) {
        for(int j=0;j<nRang;j++) {
          if(B[i][j] == Double.MAX_VALUE) System.out.print(" INF"); else System.out.print(" " + B[i][j]);
        }
        System.out.println();
      }
//-----------------------------------------------------------------------------------*/
      solucio = 1000;
    }
    return solucio;          
  }

  protected abstract boolean calAfegirPlaneta(int ip, int idPlanetaVisitat, ArrayList<Integer> novesNecessitatsPendents, int[][] mDisponibilitats);

//  public int obtenirComptadorIdNode() { return comptadoridnode; }

//  public boolean obtenirCotaHungarian() { return cotahungarian; }
  public String obtenirNomAlgoritme() { return nomalgoritme; }

//  public void modificarCotaHungarian(boolean cotahungarian) { this.cotahungarian = cotahungarian; }
  public void modificarNomAlgoritme(String nomalgoritme) { this.nomalgoritme = nomalgoritme; }
  
}
